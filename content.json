{"pages":[],"posts":[{"title":"BM01 反转链表","text":"描述给定一个单链表的头结点pHead(该头节点是有值的，比如在下图，它的val是)，长度为，反转该链表后，返回新链表的表头。 数据范围： 要求：空间复杂度，时间复杂度。 如当输入链表{1,2,3}时， 经反转后，原链表变为{3,2,1}，所以对应的输出为{3,2,1}。 以上转换过程如下图所示： 示例1text12输入：{1,2,3}返回值：{3,2,1} 示例2text123输入：{}返回值：{}说明：空链表则输出空 解题思路由于数据量不大且只需要全反转，因此使用2个辅助节点preNode和nextNode逐个节点倒转即可。其中preNode和nextNode分别初始化为指向**所需更改节点(headNode)**的前一个节点和后一个节点。 ex：需要倒转第一个节点时，preNode节点指向空节点，nextNode指向2号节点。 单节点倒转过程分步： 使head节点指向前一个节点，即preNode.next记录的信息 使preNode.next记录当前节点信息 如果后一个节点不为空则使head与nextNode同时后移，否则说明链表到尾部，preNode置为空结束循环 123456789101112131415161718192021222324252627from hashlib import new# class ListNode:# def __init__(self, x):# self.val = x# self.next = None## @param head ListNode类 # @return ListNode类#class Solution: def ReverseList(self , head: ListNode) -&gt; ListNode: # write code here if head == None: return head preNode = ListNode(1) nextNode = head.next while preNode != None: head.next = preNode.next preNode.next = head if nextNode != None: head = nextNode nextNode = nextNode.next else: preNode = None return head","link":"https://guodnuli.github.io/2023/08/06/BM01%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"},{"title":"BM02 链表内指定区间反转","text":"描述将一个节点数为链表位置到位置之间的区间反转，要求时间复杂度，空间复杂度。 例如： 给出的链表为 , ,, 返回 . 数据范围：链表长度， 链表中每个节点的值满足 要求：时间复杂度，空间复杂度 进阶：时间复杂度，空间复杂度 示例1text12输入：{1,2,3,4,5},2,4返回值：{1,4,3,2,5} 示例2text12输入：{5},1,1返回值：{5} 解题思路明确问题与步骤 明确翻转链表的头尾，使用prev与pos进行标记 将头尾之间的链表逐步翻转 当prev为空时说明链表头已被反转后的链表头替代，直接返回heaad节点，否则返回翻转部分的头节点，即cur节点 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# class ListNode:# def __init__(self, x):# self.val = x# self.next = None## 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可## # @param head ListNode类 # @param m int整型 # @param n int整型 # @return ListNode类#class Solution: def reverseBetween(self , head: ListNode, m: int, n: int) -&gt; ListNode: if head == None or head.next == None or m == n: return head prev = None cur = head pos = None count = 0 while cur != None: count += 1 if count == m - 1: prev = cur if count == n + 1: pos = cur cur = cur.next cur = head if prev == None else prev.next cur2 = cur.next cur.next = pos cashNode = None count = m while count &lt; n: cashNode = cur2.next cur2.next = cur cur = cur2 cur2 = cashNode count += 1 if prev != None: prev.next = cur return head return cur","link":"https://guodnuli.github.io/2023/08/23/BM02%E9%93%BE%E8%A1%A8%E5%86%85%E6%8C%87%E5%AE%9A%E5%8C%BA%E9%97%B4%E5%8F%8D%E8%BD%AC/"},{"title":"BM03 链表中的节点每k个一组翻转","text":"描述将给出的链表中的节点每个一组翻转，返回翻转后的链表如果链表中的节点数不是的倍数，将最后剩下的节点保持原样你不能更改节点中的值，只能更改节点本身。 数据范围： ，，链表中每个元素都满足 要求：空间复杂度，时间复杂度 例如： 给定的链表是 对于, 你应该返回 对于, 你应该返回 示例1text12输入：{1,2,3,4,5},2返回值：{2,1,4,3,5} 示例2text12输入：{},1返回值：{} 解题思路明确问题与策略 计算链表长度 根据长度确定需要进行多少次完整的反转 对每个k节点进行反转 翻转链表的一部分为了简化问题，我们可以先编写一个辅助函数来每次翻转链表的k个节点。 这个函数可以接受链表的开始节点和结束节点，并返回翻转后的链表部分的开始节点和结束节点。 12345def reverse_partial(start: ListNode, end: ListNode) -&gt; (ListNode, ListNode): prev, curr = None, start while curr != end: curr.next, prev, curr = prev, curr, curr.next return prev, start 整合进入主函数现在我们使用reverse_partial函数逐步反转链表，每次翻转k个节点，直到没有足够的节点为止 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# class ListNode:# def __init__(self, x):# self.val = x# self.next = None## 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可## @param head ListNode类 # @param k int整型 # @return ListNode类#class Solution: def reverseKGroup(self , head: ListNode, k: int) -&gt; ListNode: def reverse_partial(start: ListNode, end: ListNode) -&gt; (ListNode, ListNode): prev, curr = None, start while curr != end: curr.next, prev, curr = prev, curr, curr.next return prev, start if not head or k == 1: return head length = 0 temp = head while temp: length += 1 temp = temp.next if length &lt; k: return head dummy = ListNode(0) dummy.next = head prev_group_end = dummy while length &gt;= k: group_start = prev_group_end.next group_end = prev_group_end.next for _ in range(k): group_end = group_end.next new_start, new_end = reverse_partial(group_start, group_end) prev_group_end.next = new_start new_end.next = group_end prev_group_end = new_end length -= k return dummy.next 首次提交（该答案可读性较差且代码冗余过多）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677# class ListNode:# def __init__(self, x):# self.val = x# self.next = None## 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可## @param head ListNode类 # @param k int整型 # @return ListNode类#class Solution: def reverseKGroup(self , head: ListNode, k: int) -&gt; ListNode: cur = head len = 0 while cur != None: len += 1 cur = cur.next if len &lt; k or len &lt;= 1 or k == 1: return head if len == k: preNode = ListNode(1) nextNode = head.next while preNode != None: head.next = preNode.next preNode.next = head if nextNode != None: head = nextNode nextNode = nextNode.next else: preNode = None return head totalgroup = int(len / k) groupcount = 0 cur = head cur2 = cur.next pre = ListNode(None) pre.next = head pos = ListNode(None) lastNode = ListNode(None) while groupcount &lt; totalgroup: groupcount += 1 count = 0 while count &lt; k: cur = cur.next count += 1 if count == k - 1: lastNode = cur if count == k: pos = cur pre.next.next = pos cur = pre.next pre.next = lastNode pre = cur cashNode = None count = 0 while count &lt; k: if count &lt; k - 1: cashNode = cur2.next cur2.next = cur cur = cur2 cur2 = cashNode if groupcount == 1: head = cur else: cur = cur2 cur2 = cur2.next count += 1 return head","link":"https://guodnuli.github.io/2023/08/23/BM03%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9%E6%AF%8Fk%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC/"},{"title":"BM04 合并两个排序的链表","text":"描述输入两个递增的链表，单个链表的长度为，合并这两个链表并使新链表中的节点仍然是递增排序的。 数据范围：，节点值 要求：空间复杂度，时间复杂度 如输入{1,3,5},{2,4,6}时，合并后的链表为{1,2,3,4,5,6}，所以对应的输出为{1,2,3,4,5,6}，转换过程如下图所示： 或输入{-1,2,4},{1,3,4}时，合并后的链表为{-1,1,2,3,4,4}，所以对应的输出为{-1,1,2,3,4,4}，转换过程如下图所示： 示例1text12输入：{1,3,5},{2,4,6}返回值：{1,2,3,4,5,6} 示例2text12输入：{},{}返回值：{} 示例3text12输入：{-1,2,4},{1,3,4}返回值：{-1,1,2,3,4,4} 解题思路明确问题和步骤 由于需要原地操作，所以选定一个链表作为主链表，另外一个链表为合并的副链表 123456789101112131415161718192021222324252627282930313233343536# class ListNode:# def __init__(self, x):# self.val = x# self.next = None## 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可## # @param pHead1 ListNode类 # @param pHead2 ListNode类 # @return ListNode类#class Solution: def Merge(self, pHead1: ListNode, pHead2: ListNode) -&gt; ListNode: if not pHead1: return pHead2 if not pHead2: return pHead1 if pHead1.val &gt; pHead2.val: pHead1, pHead2 = pHead2, pHead1 prev = None curr = pHead1 while pHead1 and pHead2: if pHead1.val &lt;= pHead2.val: prev = pHead1 pHead1 = pHead1.next else: prev.next, prev, pHead2.next, pHead2 = pHead2, pHead2, pHead1, pHead2.next if pHead2: prev.next = pHead2 return curr","link":"https://guodnuli.github.io/2023/08/23/BM04%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/"},{"title":"BM06 判断链表中是否有环","text":"描述题目描述文本 判断给定的链表中是否有环。如果有环则返回，否则返回。 数据范围：链表长度 ，链表中任意节点的值满足 要求：空间复杂度，时间复杂度 输入分为两部分，第一部分为链表，第二部分代表是否有环，然后将组成的head头结点传入到函数里面。代表无环，其它的数字代表有环，这些参数解释仅仅是为了方便读者自测调试。实际在编程时读入的是链表的头节点。 例如输入{3,2,0,-4},1时，对应的链表结构如下图所示： 可以看出环的入口结点为从头结点开始的第个结点（注：头结点为第个结点），所以输出。 示例1text123输入：{3,2,0,-4},1返回值：true说明：第一部分{3,2,0,-4}代表一个链表，第二部分的1表示，-4到位置1（注：头结点为位置0），即-4-&gt;2存在一个链接，组成传入的head为一个带环的链表，返回true 示例2text123输入：{1},-1返回值：false说明：第一部分{1}代表一个链表，-1代表无环，组成传入head为一个无环的单链表，返回false 示例3text12输入：{-1,-7,7,-4,19,6,-9,-5,-2,-5},6返回值：true 解题思路正解可以使用快慢指针的做法，详细的数学证明在这里。 步骤 链表头设置快慢指针，快指针每次前进2步，慢指针每次前进1步。 此时会有两种情况，第一种便是快指针到达链表尾部，说明没有环；第二种则是有环且快指针跑追上慢指针，两指针相等。 异常情况则是链表为空 123456789101112131415161718192021222324# class ListNode:# def __init__(self, x):# self.val = x# self.next = None# # @param head ListNode类 # @return bool布尔型#class Solution: def hasCycle(self , head: ListNode) -&gt; bool: if not head: return False fastptr = head slowptr = head while fastptr: for _ in list(range(2)): if fastptr.next: fastptr = fastptr.next else: return False slowptr = slowptr.next if fastptr == slowptr: return True 偷懒做法 😛12345678910111213141516171819# class ListNode:# def __init__(self, x):# self.val = x# self.next = None# # @param head ListNode类 # @return bool布尔型#class Solution: def hasCycle(self , head: ListNode) -&gt; bool: if not head: return False len = 0 while head.next: len += 1 head = head.next if len &gt; 10000: return True return False","link":"https://guodnuli.github.io/2023/08/25/BM06%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E4%B8%AD%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF/"},{"title":"BM05 合并k个已排序的链表","text":"描述合并个升序的链表并将结果作为一个升序的链表返回其头节点。 数据范围：节点总数 ，每个节点的val满足 要求：时间复杂度 示例1text12输入：[{1,2,3},{4,5,6,7}]返回值：{1,2,3,4,5,6,7} 示例2text12输入：[{1,2},{1,4,5},{6}]返回值：{1,1,2,4,5,6} 解题思路明确问题与步骤 使用冒泡排序在lists中寻找最小值节点，将其放置于列表首位 与BM04相同，使副链表逐步合并进入主链表 异常场景考虑：空节点、两链表不同长度 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455# class ListNode:# def __init__(self, x):# self.val = x# self.next = None## 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可## # @param lists ListNode类一维数组 # @return ListNode类#class Solution: def mergeKLists(self , lists: List[ListNode]) -&gt; ListNode: len = lists.__len__() if not lists: return None if len == 1: return lists[0] index = 0 while not lists[0]: index += 1 if lists[index]: lists[0], lists[index] = lists[index], lists[0] if index == len - 1 and not lists[0]: return None for i in list(range(len)): if not lists[i]: pass elif lists[i].val &lt; lists[0].val: lists[i], lists[0] = lists[0], lists[i] cur = lists[0] head = lists[0] pre = ListNode(0) pre.next = cur for i in lists[1:]: if not i: continue addNode = i while cur and addNode: if cur.val &gt; addNode.val: pre.next, addNode.next, pre, addNode = addNode, cur, addNode, addNode.next else: cur, pre = cur.next, cur if addNode: pre.next = addNode cur = head return head","link":"https://guodnuli.github.io/2023/08/25/BM05%E5%90%88%E5%B9%B6k%E4%B8%AA%E5%B7%B2%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/"},{"title":"BM07 链表中环的入口结点","text":"描述给一个长度为n链表，若其中包含环，请找出该链表的环的入口结点，否则，返回null。 数据范围： ，结点值 要求：空间复杂度，时间复杂度 例如，输入{1,2},{3,4,5}时，对应的环形链表如下图所示： 可以看到环的入口结点的结点值为，所以返回结点值为的结点。 输入描述输入分为段，第一段是入环前的链表部分，第二段是链表环的部分，后台会根据第二段是否为空将这两段组装成一个无环或者有环单链表 返回值描述返回链表的环的入口结点即可，我们后台程序会打印这个结点对应的结点值；若没有，则返回对应编程语言的空结点即可。 示例1text123输入：{1,2},{3,4,5}返回值：3说明：返回环形链表入口结点，我们后台程序会打印该环形链表入口结点对应的结点值，即3 示例2text123输入：{1},{}返回值：\"null\"说明：没有环，返回对应编程语言的空结点，后台程序会打印\"null\" 示例3text123输入：{},{2}返回值：2说明：环的部分只有一个结点，所以返回该环形链表入口结点，后台程序打印该结点对应的结点值，即2 解题思路明确问题与步骤与BM06相同，使用快慢指针解题，详细数学证明在这里。具体做法如下 设置快慢指针，起点均为头部指针。快指针每次走两步，慢指针每次走一步。 若快指针遇到结尾，即空节点，说明没有环。 若快慢指针相遇，则说明有环，此时退出第一个循环，并重新设置一个头指针ptr。 ptr与慢指针相同每次走一步，当ptr与慢指针遭遇时，遭遇时的节点即为入环节点。 12345678910111213141516171819202122232425262728# -*- coding:utf-8 -*-# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def EntryNodeOfLoop(self, pHead): if not pHead: return None fastptr = pHead slowptr = pHead while fastptr: for _ in list(range(2)): if fastptr.next: fastptr = fastptr.next else: return None slowptr = slowptr.next if fastptr == slowptr: break ptr = pHead while ptr != slowptr: ptr = ptr.next slowptr = slowptr.next return ptr","link":"https://guodnuli.github.io/2023/08/26/BM07%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E7%BB%93%E7%82%B9/"},{"title":"BM08 链表中倒数最后k个结点","text":"描述输入一个长度为的链表，设链表中的元素的值为，返回该链表中倒数第个节点。 如果该链表长度小于，请返回一个长度为的链表。 数据范围：，， 要求：空间复杂度 ，时间复杂度 进阶：空间复杂度 ，时间复杂度 例如输入{1,2,3,4,5},2时，对应的链表结构如下图所示： 其中蓝色部分为该链表的最后个结点，所以返回倒数第个结点（也即结点值为的结点）即可，系统会打印后面所有的节点来比较。 示例1text123输入：{1,2,3,4,5},2返回值：{4,5}说明：返回倒数第2个节点4，系统会打印后面所有的节点来比较。 示例2text12输入：{2},8返回值：{} 解题思路明确问题与步骤 循环取得链表长度 设置答案节点ans，循环次后返回即可 异常场景：链表为空，， 12345678910111213141516171819202122232425262728293031# class ListNode:# def __init__(self, x):# self.val = x# self.next = None## 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可## # @param pHead ListNode类 # @param k int整型 # @return ListNode类#class Solution: def FindKthToTail(self , pHead: ListNode, k: int) -&gt; ListNode: if not pHead and k == 0: return None len = 0 curr = pHead while curr: len += 1 curr = curr.next if len &lt; k: return None ans = pHead for i in list(range(len - k)): ans = ans.next return ans","link":"https://guodnuli.github.io/2023/08/26/BM08%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E6%9C%80%E5%90%8Ek%E4%B8%AA%E7%BB%93%E7%82%B9/"},{"title":"BM09 删除链表的倒数第n个节点","text":"描述给定一个链表，删除链表的倒数第个节点并返回链表的头指针例如， 给出的链表为:, . 删除了链表的倒数第个节点之后,链表变为. 数据范围：链表长度，链表中任意节点的值满足 要求：空间复杂度，时间复杂度 备注：题目保证一定是有效的 示例1text12输入：{1,2},2返回值：{2} 解题思路 循环取得链表长度后再次循环找到倒数第n个节点，修改前节点后驱即可 1234567891011121314151617181920212223242526272829303132333435# class ListNode:# def __init__(self, x):# self.val = x# self.next = None## 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可## # @param head ListNode类 # @param n int整型 # @return ListNode类#class Solution: def removeNthFromEnd(self , head: ListNode, n: int) -&gt; ListNode: if not head: return None if n == 0: return head curr = head len = 0 while curr: len += 1 curr = curr.next if len == n: return head.next pre = ListNode(0) pre.next = head curr = head for i in list(range(len - n)): curr, pre = curr.next, pre.next pre.next, curr.next = curr.next, None return head","link":"https://guodnuli.github.io/2023/08/27/BM09%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E8%8A%82%E7%82%B9/"},{"title":"BM10 两个链表的第一个公共结点","text":"描述输入两个无环的单向链表，找出它们的第一个公共结点，如果没有公共节点则返回空。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的） 数据范围： 要求：空间复杂度，时间复杂度 例如，输入{1,2,3},{4,5},{6,7}时，两个无环的单向链表的结构如下图所示： 可以看到它们的第一个公共结点的结点值为，所以返回结点值为的结点。 输入描述输入分为是段，第一段是第一个链表的非公共部分，第二段是第二个链表的非公共部分，第三段是第一个链表和第二个链表的公共部分。 后台会将这3个参数组装为两个链表，并将这两个链表对应的头节点传入到函数FindFirstCommonNode里面，用户得到的输入只有pHead1和pHead2。 返回值描述返回传入的pHead1和pHead2的第一个公共结点，后台会打印以该节点为头节点的链表。 示例1text12345输入：{1,2,3},{4,5},{6,7}返回值：{6,7}说明：第一个参数{1,2,3}代表是第一个链表非公共部分，第二个参数{4,5}代表是第二个链表非公共部分，最后的{6,7}表示的是2个链表的公共部分这3个参数最后在后台会组装成为2个两个无环的单链表，且是有公共节点的 示例2text123输入：{1},{2,3},{}返回值：{}说明：2个链表没有公共节点 ,返回null，后台打印{} 解题思路明确问题与步骤 定义get_list_len函数取得两链表长度 123456def get_list_len(pHead) -&gt; int: len = 0 while pHead: len += 1 pHead = pHead.next return len 根据两链表长度，使ptr1始终保持长链 使长链指针先移动len1-len2长度 再同时移动两指针直至相遇或ptr1和ptr2均为None时返回答案 异常情况：其中任意一个头指针为空时返回None 1234567891011121314151617181920212223242526272829303132333435363738394041424344# class ListNode:# def __init__(self, x):# self.val = x# self.next = None# # @param pHead1 ListNode类 # @param pHead2 ListNode类 # @return ListNode类#class Solution: def FindFirstCommonNode(self, pHead1, pHead2) -&gt; ListNode: def get_list_len(pHead) -&gt; int: len = 0 while pHead: len += 1 pHead = pHead.next return len if not pHead1 or not pHead2: return None ptr1 = pHead1 ptr2 = pHead2 len1 = get_list_len(ptr1) len2 = get_list_len(ptr2) if len1 == 0: return pHead1 elif len2 == 0: return pHead2 ptr1 = pHead1 ptr2 = pHead2 if len1 &lt; len2: len1, len2 = len2, len1 ptr1, ptr2 = ptr2, ptr1 for _ in list(range(len1 - len2)): ptr1 = ptr1.next while ptr1: if ptr1 == ptr2: return ptr1 ptr1, ptr2 = ptr1.next, ptr2.next","link":"https://guodnuli.github.io/2023/08/27/BM10%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E7%BB%93%E7%82%B9/"},{"title":"BM11 链表相加(二)","text":"描述假设链表中每一个节点的值都在之间，那么链表整体就可以代表一个整数。 给定两个这种链表，请生成代表两个整数相加值的结果链表。 数据范围：，链表任意值 要求：空间复杂度，时间复杂度 例如： 链表为 ，链表为，最后生成新的结果链表为 示例1text12输入：[9,3,7],[6,3]返回值：{1,0,0,0} 示例2text12输入：[0],[6,3]返回值：{6,3} 备注 解题思路 翻转两链表并比较两链表长度，置head1为长链表指针 从低位开始相加，使用carry记录进位信息 双链表相加结束后将长链表剩余位数连接，同样使用carry记录进位 最后翻转结果链表并返回 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677# class ListNode:# def __init__(self, x):# self.val = x# self.next = None## 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可## # @param head1 ListNode类 # @param head2 ListNode类 # @return ListNode类#class Solution: def addInList(self , head1: ListNode, head2: ListNode) -&gt; ListNode: def reverseList(head: ListNode) -&gt; ListNode: preNode = ListNode(0) nextNode = head.next while preNode: head.next = preNode.next preNode.next = head if nextNode: head = nextNode nextNode = nextNode.next else: preNode = None return head def compareListSize(head1: ListNode, head2: ListNode) -&gt; bool: while head1 and head2: head1 = head1.next head2 = head2.next if head1: return True else: return False if not head1: return head2 elif not head2: return head1 head1 = reverseList(head1) head2 = reverseList(head2) cur1, cur2 = head1, head2 if not compareListSize(cur1, cur2): head1, head2 = head2, head1 preNode = ListNode(0) curr = preNode carry = False while head1 and head2: val = head1.val + head2.val if carry: val += 1 if val &gt; 9: val %= 10 carry = True else: carry = False curr.next= ListNode(val) curr = curr.next head1, head2 = head1.next, head2.next while head1: val = head1.val if carry: val += 1 if val &gt; 9: val %= 10 carry = True else: carry = False curr.next= ListNode(val) curr = curr.next head1 = head1.next return reverseList(preNode.next)","link":"https://guodnuli.github.io/2023/08/28/BM11%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%8A%A0-%E4%BA%8C/"},{"title":"BM12 单链表的排序","text":"描述给定一个节点数为n的无序单链表，对其按升序排序。 数据范围：，保证节点权值在之内。 要求：空间复杂度$O(n)，时间复杂度O(nlogn)$ 示例1text12输入：[1,3,2,4,5]返回值：{1,2,3,4,5} 示例2text12输入：[-1,0,-2]返回值：{-2,-1,0} 解题思路解法1：使用支持随机读写的数据结构复制数据域，如python中的list，再用排序算法在list中排序后全部赋值到链表中。 解法2：将排序算法改造为链表适用后直接在链表上进行排序。 该题的数据量比较大，使用解法1会超时，因此使用第二种解法，使用归并排序。 明确步骤 使用快慢指针将链表分为2部分，当不可再分时返回节点 合并左右两边为一个大的部分并返回 递归地调用1和2步即可返回1个完全排序的链表 12345678910111213141516171819202122232425262728293031323334353637383940414243444546# class ListNode:# def __init__(self, x):# self.val = x# self.next = None## 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可## @param head ListNode类 the head node# @return ListNode类#class Solution: def sortInList(self , head: ListNode) -&gt; ListNode: def mergesort(head: ListNode) -&gt; ListNode: if not head or not head.next: return head fastptr, slowptr = head, head while fastptr.next and fastptr.next.next: fastptr = fastptr.next.next slowptr = slowptr.next middle, slowptr.next = slowptr.next, None left = mergesort(head) right = mergesort(middle) return merge(left, right) def merge(left: ListNode, right: ListNode) -&gt; ListNode: dummy = ListNode(0) curr = dummy while left and right: if left.val &lt;= right.val: curr.next, left= left, left.next curr = curr.next else: curr.next, right = right, right.next curr = curr.next if left: curr.next = left if right: curr.next = right return dummy.next return mergesort(head)","link":"https://guodnuli.github.io/2023/08/28/BM12%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8E%92%E5%BA%8F/"},{"title":"BM13 判断一个链表是否为回文结构","text":"描述给定一个链表，请判断该链表是否为回文结构。 回文是指该字符串正序逆序完全一致。 数据范围： 链表节点数，链表中每个节点的值满足 示例1text12输入：{1}返回值：true 示例2text123输入：{2,1}返回值：false说明：2-&gt;1 示例3text123输入：{1,2,2,1}返回值：true说明：1-&gt;2-&gt;2-&gt;1 解题思路 使用快慢指针从中点断开链表 将后一段链表倒转 前链表从头读取，后链表从尾读取，逐个比较，当不相等时返回false，当其中一个为None时还没有出现不相等的情况则返回true 123456789101112131415161718192021222324252627282930313233343536373839404142# class ListNode:# def __init__(self, x):# self.val = x# self.next = None## 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可## # @param head ListNode类 the head# @return bool布尔型#class Solution: def isPail(self , head: ListNode) -&gt; bool: def reverseList(head: ListNode) -&gt; ListNode: preNode = ListNode(0) nextNode = head.next while preNode: head.next = preNode.next preNode.next = head if nextNode: head = nextNode nextNode = nextNode.next else: preNode = None return head if not head or not head.next: return True fast = head slow = head while fast.next and fast.next.next: slow, fast = slow.next, fast.next.next mid, slow.next = slow.next, None mid = reverseList(mid) while mid and head: if mid.val != head.val: return False mid, head = mid.next, head.next return True","link":"https://guodnuli.github.io/2023/08/28/BM13%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E4%B8%BA%E5%9B%9E%E6%96%87%E7%BB%93%E6%9E%84/"},{"title":"BM14 链表的奇偶重排","text":"描述给定一个单链表，请设定一个函数，将链表的奇数位节点和偶数位节点分别放在一起，重排后输出。 注意是节点的编号而非节点的数值。 数据范围：节点数量满足，节点中的值都满足 要求：空间复杂度，时间复杂度 示例1text123456输入：{1,2,3,4,5,6}返回值：{1,3,5,2,4,6}说明：1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;NULL重排后为1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;6-&gt;NULL 示例2text1234567输入：{1,4,6,3,7}返回值：{1,6,7,4,3}说明：1-&gt;4-&gt;6-&gt;3-&gt;7-&gt;NULL重排后为1-&gt;6-&gt;7-&gt;4-&gt;3-&gt;NULL奇数位节点有1,6,7，偶数位节点有4,3。重排后为1,6,7,4,3 备注text1链表长度不大于200000。每个数范围均在int内。 解题思路 新建两个哨兵结点dummyOdd与dummyEven分别建立奇数链表和偶数链表，并使用flag作为奇偶标志位 交替向两个链表添加节点，以flag的bool值作为标准 添加完毕后将偶数链表接到奇数链表后并返回即可 1234567891011121314151617181920212223242526272829303132333435# class ListNode:# def __init__(self, x):# self.val = x# self.next = None## 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可## # @param head ListNode类 # @return ListNode类#class Solution: def oddEvenList(self , head: ListNode) -&gt; ListNode: if not head: return None dummyOdd = ListNode(0) dummyEven = ListNode(0) currOdd = dummyOdd currEven = dummyEven flag = True # 真为奇数,假为偶数 while head: if flag: currOdd.next, head = head, head.next currOdd = currOdd.next currOdd.next = None flag = False else: currEven.next, head= head, head.next currEven = currEven.next currEven.next = None flag = True currOdd.next = dummyEven.next return dummyOdd.next","link":"https://guodnuli.github.io/2023/08/28/BM14%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A5%87%E5%81%B6%E9%87%8D%E6%8E%92/"},{"title":"BM15 删除有序链表中重复的元素-I","text":"描述删除给出链表中的重复元素（链表中元素从小到大有序），使链表中的所有元素都只出现一次 例如： 给出的链表为，返回 给出的链表为，返回 数据范围：链表长度满足，链表中任意节点的值满足 进阶：空间复杂度，时间复杂度 示例1text12输入：{1,1,2}返回值：{1,2} 示例2text12输入：{}返回值：{} 解题思路 设置一前一后两个指针，当后指针数值与前指针相等时更改前指针的后驱为后指针的后驱实现跳过相同数值的节点 1234567891011121314151617181920212223# class ListNode:# def __init__(self, x):# self.val = x# self.next = None## 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可## # @param head ListNode类 # @return ListNode类#class Solution: def deleteDuplicates(self , head: ListNode) -&gt; ListNode: if not head or not head.next: return head curr = head pos = head.next while pos: if curr.val == pos.val: curr.next, pos = pos.next, pos.next else: curr, pos = curr.next, pos.next return head","link":"https://guodnuli.github.io/2023/08/28/BM15%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E5%85%83%E7%B4%A0-I/"},{"title":"BM16 删除有序链表中重复的元素-II","text":"描述给出一个升序排序的链表，删除链表中的所有重复出现的元素，只保留原链表中只出现一次的元素。 例如： 给出的链表为 返回 给出的链表为 返回 数据范围：链表长度，链表中的值满足 要求：空间复杂度，时间复杂度 进阶：空间复杂度，时间复杂度 示例1text12输入：{1,2,2}返回值：{1} 示例2text12输入：{}返回值：{} 解题思路 设置三个节点，prev跳过区间的前节点，start跳过区间头节点，end跳过区间尾节点 当头节点值与尾节点值相等时找到重复值的尾部，调整prev指向end后一个节点并后移start和end 1234567891011121314151617181920212223242526272829303132333435# class ListNode:# def __init__(self, x):# self.val = x# self.next = None## 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可# # @param head ListNode类 # @return ListNode类#class Solution: def deleteDuplicates(self , head: ListNode) -&gt; ListNode: if not head: return head dummyNode = ListNode(0) prev = dummyNode prev.next = head start = head end = start.next while end: if start.val == end.val: while end.next and end.val == end.next.val: end = end.next prev.next = end.next if not prev.next: return dummyNode.next start = prev.next end = start.next else: prev = prev.next end = end.next start = start.next return dummyNode.next","link":"https://guodnuli.github.io/2023/08/28/BM16%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E5%85%83%E7%B4%A0-II/"},{"title":"BM17 二分查找-I","text":"描述请实现无重复数字的升序数组的二分查找 给定一个 元素升序的、无重复数字的整型数组nums和一个目标值 target，写一个函数搜索nums中的target，如果目标值存在返回下标（下标从开始），否则返回 数据范围： ， 数组中任意值满足 进阶：时间复杂度，空间复杂度 示例1text123输入：[-1,0,3,4,6,10,13,14],13返回值：6说明：13 出现在nums中并且下标为 6 示例2text123输入：[],3返回值：-1说明：nums为空，返回-1 示例3text123输入：[-1,0,3,4,6,10,13,14],2返回值：-1说明：2不存在nums中因此返回-1 备注text12数组元素长度在$[0,10000]$之间数组每个元素都在[-9999, 9999]之间。 解题思路实现二分查找即可 函数操作步骤 检查左右边界值，当左右边界值相等或右小于左时说明无目标值，返回 比较子数组中点值是否为目标值，相等时返回索引middle 根据目标值大小递归调用函数，目标值小于当前中点值则搜索前半部分，大于则搜索后半部分 123456789101112131415161718192021222324## 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可## @param nums int整型一维数组 # @param target int整型 # @return int整型#class Solution: def search(self , nums: List[int], target: int) -&gt; int: def binarySearch(nums: List[int], target: int, left: int, right: int) -&gt; int: if left &lt;= right: middle = left + (right - left) // 2 if nums[middle] == target: return middle elif nums[middle] &lt; target: return binarySearch(nums, target, middle + 1, right) else: return binarySearch(nums, target, left, middle - 1) else: return -1 if not nums: return -1 return binarySearch(nums, target, 0, nums.__len__() - 1)/ 优化前代码由于递归调用时使用了List切片运算，创建了新的子列表，导致了额外的内存分配和额外的赋值操作，算法效率低，在提交时应该是爆内存了导致没有AC 123456789101112131415161718192021222324## 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可## @param nums int整型一维数组 # @param target int整型 # @return int整型#class Solution: def search(self , nums: List[int], target: int) -&gt; int: def binarySearch(nums: List[int], target: int, index: int) -&gt; int: middle = int(nums.__len__()/2) if nums.__len__() == 1 and nums[0] != target: return -1 if nums[middle] == target: return middle + index elif nums[middle] &lt; target: return binarySearch(nums[middle:], target, middle) elif nums[middle] &gt; target: return binarySearch(nums[:middle], target, index + 0) if not nums: return -1 return binarySearch(nums, target, 0)","link":"https://guodnuli.github.io/2023/08/28/BM17%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-I/"},{"title":"BM18 二维数组中的查找","text":"描述在一个二维数组array中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 [ [1,2,8,9], [2,4,9,12], [4,7,10,13], [6,8,11,15] ] 给定，返回true 给定，返回false 数据范围：矩阵的长宽满足，矩阵中的值满足进阶：空间复杂度，时间复杂度 示例1text123输入：7,[[1,2,8,9],[2,4,9,12],[4,7,10,13],[6,8,11,15]]返回值：true说明：存在7，返回true 示例2text12输入：1,[[2]]返回值：false 示例3text123输入：3,[[1,2,8,9],[2,4,9,12],[4,7,10,13],[6,8,11,15]]返回值：false说明：不存在3，返回false 解题思路 从角落开始搜索（四个角落都可以），初始化扫描起点，此函数从右上角开始扫描 如果相等，说明找到了目标元素 当前值小于目标时，说明元素可能在当前行的右边，向下移动1行 当前值大于目标时，说明元素可能在当前列的上方，向左移动1列 该算法每次可排除一行或者一列，重复步骤直到找到目标或超出数组边界 123456789101112131415161718192021222324## 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可## @param target int整型 # @param array int整型二维数组 # @return bool布尔型#class Solution: def Find(self , target: int, array: List[List[int]]) -&gt; bool: rows, cols = array.__len__(), array[0].__len__() if not array or rows == 0 or cols == 0: return False row, col = 0, cols - 1 while row &lt; rows and col &gt;= 0: if array[row][col] == target: return True elif array[row][col] &lt; target: row += 1 else: col -= 1 return False","link":"https://guodnuli.github.io/2023/08/28/BM18%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/"},{"title":"BM19 寻找峰值","text":"描述给定一个长度为n的数组nums，请你找到峰值并返回其索引。数组可能包含多个峰值，在这种情况下，返回任何一个所在位置即可。 1.峰值元素是指其值严格大于左右相邻值的元素。严格大于即不能有等于 2.假设 3.对于所有有效的i都有nums[i]!=nums[i + 1] 4.你可以使用的时间复杂度实现此问题吗？ 数据范围： 如输入[2,4,1,2,7,8,4]时，会形成两个山峰，一个是索引为，峰值为的山峰，另一个是索引为，峰值为的山峰，如下图所示： 示例1text123输入：[2,4,1,2,7,8,4]返回值：1说明：4和8都是峰值元素，返回4的索引1或者8的索引5都可以 示例2text123输入：[1,2,3,1]返回值：2说明：3是峰值元素，返回其索引2 解题思路优化前代码笨方法，没有认识到问题本质是证明极值存在，相当于普通的二分法，如果在半边没有遍历到山峰(极值)时会再遍历另外一边。 12345678910111213141516171819202122232425262728293031323334353637## 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可## # @param nums int整型一维数组 # @return int整型#class Solution: def findPeakElement(self , nums: List[int]) -&gt; int: def check(nums: List[int], index: int) -&gt; bool: if index == 0 and nums[index + 1] &lt; nums[index]: return True elif index == len(nums) - 1 and nums[index - 1] &lt; nums[index]: return True if nums[index] &gt; nums[index - 1] and nums[index] &gt; nums[index + 1]: return True else: return False def binarySearch(nums: List[int], left: int, right: int) -&gt; int: if left &lt;= right: middle = left + (right - left) // 2 if check(nums, middle): return middle leftans = binarySearch(nums, left, middle - 1) rightans = binarySearch(nums, middle + 1, right) if leftans != -1: return leftans elif rightans != -1: return rightans return -1 if len(nums) == 1: return 0 return binarySearch(nums, 0, len(nums) - 1) 明确问题问题：找到极值点（左右两边数值严格小于极值点） 关键点：利用极值点左右的单调性 检查左右索引，相等时说明找到极值点 检查右侧单调性，nums[middle] &gt; nums[middle + 1]时说明当前为单调递减序列，说明极值点在左侧，否则说明当前为单调递增序列，极值点在右侧 递归调用binarySearch 1234567891011121314151617181920## 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可## @param nums int整型一维数组 # @return int整型#class Solution: def findPeakElement(self , nums: List[int]) -&gt; int: def binarySearch(nums: List[int], left: int, right: int) -&gt; int: if left == right: return left middle = left + (right - left) // 2 if nums[middle] &gt; nums[middle + 1]: return binarySearch(nums, left, middle) return binarySearch(nums, middle + 1, right) return binarySearch(nums, 0, len(nums) - 1)","link":"https://guodnuli.github.io/2023/08/28/BM19%E5%AF%BB%E6%89%BE%E5%B3%B0%E5%80%BC/"},{"title":"BM20 数组中的逆序对","text":"描述在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数。 并将对取模的结果输出。 即输出P mod 1000000007 数据范围： 对于的数据， 对于的数据， 数组中所有数字的值满足 要求：空间复杂度，时间复杂度 输入描述题目保证输入的数组中没有的相同的数字 示例1text12输入：[1,2,3,4,5,6,7,0]返回值：7 示例2text12输入：[1,2,3]返回值：0 解题思路该问题可以理解为使用冒泡排序统计将数组排序为升序时所需交换的次数 分治法：将数组分成两半，分别求解左右部分的逆序对数量 归并排序：在合并左右两个有序子数组的过程中，统计逆序对的数量。具体步骤如下： 在合并两个有序数组时，使用两个指针分别指向左右两个子数组的开头。 如果左子数组的当前元素小于等于右子数组的当前元素，说明没有逆序对产生，将左子数组的当前元素放入合并后的数组中，并将左指针右移。 如果左子数组的当前元素大于右子数组的当前元素，说明逆序对产生，将右子数组的当前元素放入合并后的数组中，并将右指针右移，并且逆序对数量需要增加。这是因为如果左子数组的当前元素大于右子数组的当前元素，那么左子数组中当前元素及其之后的元素都大于右子数组的当前元素，因此都构成逆序对。 继续上述过程，直到合并完成。 递归：递归地处理左右两半部分，并将左半部分和右半部分的逆序对数量相加，即为总的逆序对数量。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748## 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可## @param nums int整型一维数组 # @return int整型#class Solution: def InversePairs(self , nums: List[int]) -&gt; int: def mergeSort(nums:List[int], copy:List[int], left:int, right:int) -&gt; int: if left == right: return 0 length = (right - left) // 2 leftcount = mergeSort(nums, copy, left, left + length) rightcount = mergeSort(nums, copy, left + length + 1, right) i = left + length j = right copyindex = right count = 0 while i &gt;= left and j &gt;= left + length + 1: if nums[i] &gt; nums[j]: copy[copyindex] = nums[i] copyindex -= 1 i -= 1 count += j - left - length else: copy[copyindex] = nums[j] copyindex -= 1 j -= 1 while i &gt;= left: copy[copyindex] = nums[i] copyindex -= 1 i -= 1 while j &gt;= left + length + 1: copy[copyindex] = nums[j] copyindex -= 1 j -= 1 for i in range(left, right + 1): nums[i] = copy[i] return count + leftcount + rightcount copy = [0] * nums.__len__() return mergeSort(nums, copy, 0, nums.__len__() - 1) % 1000000007","link":"https://guodnuli.github.io/2023/08/29/BM20%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/"},{"title":"BM21 旋转数组的最小数字","text":"描述有一个长度为的非降序数组，比如[1,2,3,4,5]，将它进行旋转，即把一个数组最开始的若干个元素搬到数组的末尾，变成一个旋转数组，比如变成了[3,4,5,1,2]，或者[4,5,1,2,3]这样的。请问，给定这样一个旋转数组，求数组中的最小值。 数据范围： 数组中任意元素的值： 要求：空间复杂度：，时间复杂度： 示例1text12输入：[3,4,5,1,2]返回值：1 示例2text12输入：[3,100,200,3]返回值：3 解题思路 定义指针分别为start和end，分别指向旋转数组的起始和结束位置 每一次迭代计算mid = start + (end - start) // 2 比较nums[mid]和nums[end] 如果nums[mid] &lt; nums[end]，说明最小值在mid的左侧（包含mid），end更新为mid 如果nums[mid] &gt; nums[end]，说明最小值在mid的右侧（不包含mid），start更新为mid+1 如果nums[mid] == nums[end]，无法确定最小值在哪，但是可以将right缩小一步，不会错过nums[mid]是最小值的可能性 重复2~3步，直到start == end，nums[start]就是最小值 12345678910111213141516171819## 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可## # @param nums int整型一维数组 # @return int整型#class Solution: def minNumberInRotateArray(self , nums: List[int]) -&gt; int: start, end = 0, nums.__len__() - 1 while start &lt; end: mid = start + (end - start) // 2 if nums[mid] &lt; nums[end]: end = mid elif nums[mid] &gt; nums[end]: start = mid + 1 else: end -= 1 return nums[start]","link":"https://guodnuli.github.io/2023/08/30/BM21%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/"},{"title":"BM22 比较版本号","text":"描述牛客项目发布项目版本时会有版本号，比如1.02.11，2.14.4等等。 现在给你个版本号version1和version2，请你比较他们的大小。 版本号是由修订号组成，修订号与修订号之间由一个”.”连接。个修订号可能有多位数字组成，修订号可能包含前导，且是合法的。例如，1.02.11，0.1，0.2都是合法的版本号。 每个版本号至少包含个修订号。 修订号从左到右编号，下标从开始，最左边的修订号下标为，下一个修订号下标为，以此类推。 比较规则： 比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较忽略任何前导零后的整数值。比如0.1和0.01的版本号是相等的 如果版本号没有指定某个下标处的修订号，则该修订号视为0。例如，1.1的版本号小于1.1.1。因为1.1的版本号相当于1.1.0，第位修订号的下标为0，小于1 version1 &gt; version2返回，如果version1 &lt; version2返回，不然返回. 数据范围： version1和version2的修订号不会超过int的表达范围，即不超过32位整数 的范围 进阶： 空间复杂度，时间复杂度 示例1text1234输入：\"1.1\",\"2.1\"返回值：-1说明：version1 中下标为 0 的修订号是 \"1\"，version2 中下标为 0 的修订号是 \"2\" 。1 &lt; 2，所以version1 &lt; version2，返回-1 示例2text123输入：\"1.1\",\"1.01\"返回值：0说明：version2忽略前导0，为\"1.1\"，和version相同，返回0 示例3text1234输入：\"1.1\",\"1.1.1\"返回值：-1说明：\"1.1\"的版本号小于\"1.1.1\"。因为\"1.1\"的版本号相当于\"1.1.0\"，第3位修订号的下标为0，小于1，所以version1 &lt; version2，返回-1 示例4text123输入：\"2.0.1\",\"2\"返回值：1说明：version1的下标2&gt;version2的下标2，返回1 示例5text123输入：\"0.226\",\"0.36\"返回值：1说明：226&gt;36，version1的下标2&gt;version2的下标2，返回1 解题思路 将两个版本号以“.”为分隔符分割为列表，使用int()将字符转转化为整型并忽略前导0 双指针比较两整形列表的值 双指针循环结束后找到未循环完毕的指针继续循环，找到一个不为0的数证明该版本号更大 后续均为0的话则一样大，返回0 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647## 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可## 比较版本号# @param version1 string字符串 # @param version2 string字符串 # @return int整型#class Solution: def compare(self , version1: str, version2: str) -&gt; int: def str_to_int(str1: str) -&gt; List[int]: listint = [] liststr = str1.split('.') for i in liststr: listint.append(int(i)) return listint if version1 == version2: return 0 list1 = str_to_int(version1) list2 = str_to_int(version2) index1 = 0 index2 = 0 while index1 &lt; list1.__len__() and index2 &lt; list2.__len__(): if list1[index1] &gt; list2[index2]: return 1 elif list1[index1] &lt; list2[index2]: return -1 index1 += 1 index2 += 1 while index1 &lt; list1.__len__(): if list1[index1] &gt; 0: return 1 index1 += 1 while index2 &lt; list2.__len__(): if list2[index2] &gt; 0: return -1 index2 += 1 return 0","link":"https://guodnuli.github.io/2023/08/30/BM22%E6%AF%94%E8%BE%83%E7%89%88%E6%9C%AC%E5%8F%B7/"},{"title":"BM23 二叉树的前序遍历","text":"描述给你二叉树的根节点root，返回它节点值的前序遍历。 数据范围： 二叉树的节点数量满足 二叉树节点的值满足 ，树的各节点的值各不相同 示例 1： 示例1text12输入：{1,#,2,3}返回值：[1,2,3] 解题思路前序遍历（Preorder Traversal） 访问根节点 前序遍历左子树 前序遍历右子树 123456789101112131415161718192021222324252627# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = None## 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可## # @param root TreeNode类 # @return int整型一维数组#class Solution: def preorderTraversal(self , root: TreeNode) -&gt; List[int]: def preorder(root: TreeNode, nums: List[int]) -&gt; List[int]: nums.append(root.val) if root.left: preorder(root.left, nums) if root.right: preorder(root.right, nums) return nums nums = [] if not root: return nums return preorder(root, nums)","link":"https://guodnuli.github.io/2023/08/30/BM23%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/"},{"title":"BM24 二叉树的中序遍历","text":"描述给你二叉树的根节点root，返回它的中序遍历结果。 数据范围： 二叉树的节点数量满足 二叉树节点的值满足 进阶：空间复杂度，时间复杂度 示例1text12输入：{1,2,#,#,3}返回值：[2,3,1] 示例2text12输入：{}返回值：[] 示例3text12输入：{1,2}返回值：[2,1] 示例4text12输入：{1,#,2}返回值：[1,2] 备注text12树中节点数目在范围 [0, 100] 内树中的节点的值在[-100,100]以内 解题思路中序遍历（Inorder Traversal） 中序遍历左子树 访问根节点 中序遍历右子树 123456789101112131415161718192021222324252627282930# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = None## 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可## # @param root TreeNode类 # @return int整型一维数组#class Solution: def inorderTraversal(self , root: TreeNode) -&gt; List[int]: def inorder(root: TreeNode, ans: List[int]) -&gt; None: if root.left: inorder(root.left, ans) ans.append(root.val) if root.right: inorder(root.right, ans) return None ans = [] if not root: return ans inorder(root, ans) return ans","link":"https://guodnuli.github.io/2023/08/30/BM24%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"},{"title":"BM25 二叉树的后序遍历","text":"描述给定一个二叉树，返回他的后序遍历的序列。 后序遍历是值按照 左节点-&gt;右节点-&gt;根节点 的顺序的遍历。 数据范围： 二叉树的节点数量满足 二叉树节点的值满足 树的各节点的值各不相同 示例1text123输入：{1,#,2,3}返回值：[3,2,1]说明：如题面图 示例2text12输入：{1}返回值：[1] 解题思路后序遍历（Postorder Traversal） 后序遍历左子树 后序遍历右子树 访问根节点 123456789101112131415161718192021222324252627# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = None## 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可## # @param root TreeNode类 # @return int整型一维数组#class Solution: def postorderTraversal(self, root: TreeNode) -&gt; List[int]: def postorder(root: TreeNode, ans: List[int]) -&gt; None: if root.left: postorder(root.left, ans) if root.right: postorder(root.right, ans) ans.append(root.val) return None ans = [] if not root: return ans postorder(root, ans) return ans","link":"https://guodnuli.github.io/2023/08/30/BM25%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/"},{"title":"BM26 求二叉树的层序遍历","text":"描述给定一个二叉树，返回该二叉树层序遍历的结果，（从左到右，一层一层地遍历） 例如： 给定的二叉树是{3,9,20,#,#,15,7} 该二叉树层序遍历的结果是 [[3],[9,20],[15,7]] 提示二叉树的结点数 示例1text12输入：{1,2}返回值：[[1],[2]] 示例2text12输入：{1,2,3,4,#,#,5}返回值：[[1],[2,3],[4,5]] 解题思路方法1使用deep记录层数，在递归调用前后增加或减少其数值来维护deep参数，并使用deep作为索引来添加每层的节点值 123456789101112131415161718192021222324252627282930313233# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = None## 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可## # @param root TreeNode类 # @return int整型二维数组#class Solution: def levelOrder(self , root: TreeNode) -&gt; List[List[int]]: def search(root: TreeNode, ans: List[List[int]], deep: int) -&gt; None: if ans.__len__() &lt; deep + 1: ans.append([]) ans[deep].append(root.val) if root.left: deep += 1 search(root.left, ans, deep) deep -= 1 if root.right: deep += 1 search(root.right, ans, deep) deep -= 1 return None ans = [] if not root: return ans search(root, ans, 0) return ans","link":"https://guodnuli.github.io/2023/08/31/BM26%E6%B1%82%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"},{"title":"BM28 二叉树的最大深度","text":"描述求给定二叉树的最大深度，深度是指树的根节点到任一叶子节点路径上节点的数量。最大深度是所有叶子节点的深度的最大值。（注：叶子节点是指没有子节点的节点。） 数据范围：，树上每个节点的val满足 要求： 空间复杂度，时间复杂度 示例1text12输入：{1,2}返回值：2 示例2text12输入：{1,2,3,4,#,#,5}返回值：3 解题思路使用队列先进先出的特性来逐层遍历该层上的所有节点，当某层的叶子节点为最深深度时，它出列时队列停止，返回最大深度 123456789101112131415161718192021222324252627282930313233# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = None## 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可## # @param root TreeNode类 # @return int整型#from collections import dequeclass Solution: def maxDepth(self , root: TreeNode) -&gt; int: if not root: return 0 depth = 0 queue = deque() queue.append(root) while queue: level_size = len(queue) for i in range(level_size): node = queue.popleft() if node.left: queue.append(node.left) if node.right: queue.append(node.right) depth += 1 return depth","link":"https://guodnuli.github.io/2023/08/31/BM28%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/"},{"title":"BM27 按之字形顺序打印二叉树","text":"描述给定一个二叉树，返回该二叉树的之字形层序遍历，（第一层从左向右，下一层从右向左，一直这样交替） 数据范围： 树上每个节点的val满足 要求：空间复杂度：，时间复杂度： 例如：给定的二叉树是{1,2,3,#,#,4,5} 该二叉树之字形层序遍历的结果是[ [1], [3,2], [4,5] ] 示例1plain123输入：{1,2,3,#,#,4,5}返回值：[[1],[3,2],[4,5]]说明：如题面解释，第一层是根节点，从左到右打印结果，第二层从右到左，第三层从左到右。 示例2plain12输入：{8,6,10,5,7,9,11}返回值：[[8],[10,6],[5,7,9,11]] 示例3plain12输入：{1,2,3,4,5}返回值：[[1],[3,2],[4,5]] 解题思路按层数遍历节点后，逐单数层（索引从0开始）翻转列表内的结果。 1234567891011121314151617181920212223242526272829303132333435363738# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = None## 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可## # @param pRoot TreeNode类 # @return int整型二维数组#class Solution: def Print(self , pRoot: TreeNode) -&gt; List[List[int]]: def searchTreeNode(root: TreeNode, ans: List[List[int]], deep: int) -&gt; None: if ans.__len__() &lt; deep + 1: ans.append([]) ans[deep].append(root.val) if root.left: deep += 1 searchTreeNode(root.left, ans, deep) deep -= 1 if root.right: deep += 1 searchTreeNode(root.right, ans, deep) deep -= 1 return None ans = [] deep = 0 if not pRoot: return ans searchTreeNode(pRoot, ans, deep) while deep &lt; ans.__len__(): if deep % 2 != 0: ans[deep] = list(reversed(ans[deep])) deep += 1 return ans","link":"https://guodnuli.github.io/2023/08/31/BM27%E6%8C%89%E4%B9%8B%E5%AD%97%E5%BD%A2%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"title":"BM29 二叉树中和为某一值的路径(一)","text":"描述给定一个二叉树root和一个值sum，判断是否有从根节点到叶子节点的节点值之和等于sum的路径。 该题路径定义为从树的根结点开始往下一直到叶子结点所经过的结点 叶子节点是指没有子节点的节点 路径只能从父节点到子节点，不能从子节点到父节点 总节点数目为n 例如给出如下的二叉树，sum=22 返回true，因为存在一条路径的节点值之和为 22 数据范围： 1.树上的节点数满足 2.每 个节点的值都满足 要求：空间复杂度，时间复杂度 进阶：空间复杂度树的高度，时间复杂度 示例1text12输入：{5,4,8,1,11,#,9,#,#,2,7},22返回值：true 示例2text12输入：{1,2},0返回值：false 示例3text12输入：{1,2},3返回值：true 示例4text12输入：{},0返回值：false 解题思路方法1使用深度优先算法，遍历每条路径并使用列表记录根节点到叶子节点的和。 空间复杂度，时间复杂度 1234567891011121314151617181920212223242526272829303132333435# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = None## 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可## @param root TreeNode类 # @param sum int整型 # @return bool布尔型#class Solution: def hasPathSum(self , root: TreeNode, sum: int) -&gt; bool: def DFS(root: TreeNode, lists: List[int], sum: int): if not root: return None sum += root.val if root.left or root.right: DFS(root.left, lists, sum) DFS(root.right, lists, sum) else: lists.append(sum) return None if not root: return False lists = [] DFS(root, lists, 0) for i in lists: if i == sum: return True return False 方法2（优化后）这个优化后的代码具有以下改进： 去除了额外的列表lists，而是直接使用递归来计算路径和。这样可以减少空间复杂度。 在递归过程中，只要找到一条满足条件的路径，就可以立即返回True，而不必等到遍历完整棵树。 使用了更加明确的条件判断，当节点为叶子节点时，才检查路径和是否等于目标和。 123456789101112131415161718192021222324# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = None## @param root TreeNode类 # @param sum int整型 # @return bool布尔型#class Solution: def hasPathSum(self , root: TreeNode, sum: int) -&gt; bool: def DFS(node, target_sum): if not node: return False target_sum -= node.val if not node.left and not node.right: return target_sum == 0 return DFS(node.left, target_sum) or DFS(node.right, target_sum) if not root: return False return DFS(root, sum)","link":"https://guodnuli.github.io/2023/09/12/BM29%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84-%E4%B8%80/"},{"title":"BM30 二叉搜索树与双向链表","text":"描述输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。如下图所示 数据范围： 输入二叉树的节点数 二叉树中每个节点的值 要求：空间复杂度（即在原树上操作），时间复杂度 注意: 1.要求不能创建任何新的结点，只能调整树中结点指针的指向。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继 2.返回链表中的第一个节点的指针 3.函数返回的TreeNode，有左右指针，其实可以看成一个双向链表的数据结构 4.你不用输出双向链表，程序会根据你的返回值自动打印输出 示例1text123输入：{10,6,14,4,8,12,16}返回值：From left to right are:4,6,8,10,12,14,16;From right to left are:16,14,12,10,8,6,4;说明：输入题面图中二叉树，输出的时候将双向链表的头节点返回即可。 示例2text12345678910111213输入：{5,4,#,3,#,2,#,1}返回值：From left to right are:1,2,3,4,5;From right to left are:5,4,3,2,1;说明： 5 / 4 / 3 / 2 / 1树的形状如上图 解题思路 使用中序遍历，将节点按中序遍历顺序装入队列 在队列中遍历节点并修改节点的左右指针 返回队列头即可 12345678910111213141516171819202122232425262728293031323334353637383940414243444546# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = None# # @param pRootOfTree TreeNode类 # @return TreeNode类#from collections import dequeclass Solution: def Convert(self , pRootOfTree: TreeNode) -&gt; TreeNode: if not pRootOfTree: return pRootOfTree stack = [] queue = deque() while pRootOfTree: stack.append(pRootOfTree) pRootOfTree = pRootOfTree.left while stack: node = stack.pop() queue.append(node) if node.right: root = node.right while root: stack.append(root) root = root.left if queue.__len__() == 1: return queue.popleft() for i in range(queue.__len__()): if i == 0: queue[i].right = queue[i+1] elif i == queue.__len__() - 1: queue[i].left = queue[i-1] else: queue[i].left = queue[i-1] queue[i].right = queue[i+1] return queue.popleft() 代码优化 不必使用队列queue存储节点，因为在中序遍历过程中，节点的连接关系已经确定了。只需保持一个指向当前节点的指针即可。 可以在中序遍历的同时完成节点的连接，不必再单独遍历一次队列进行连接。 123456789101112131415161718192021222324252627282930313233343536# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = None# # @param pRootOfTree TreeNode类 # @return TreeNode类#class Solution: def Convert(self, pRootOfTree: TreeNode) -&gt; TreeNode: if not pRootOfTree: return None stack = [] prev = None # 用于记录前一个节点 while pRootOfTree or stack: while pRootOfTree: stack.append(pRootOfTree) pRootOfTree = pRootOfTree.left node = stack.pop() if prev: prev.right = node node.left = prev prev = node pRootOfTree = node.right # 找到双向链表的头部 head = prev while head and head.left: head = head.left return head","link":"https://guodnuli.github.io/2023/09/12/BM30%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"},{"title":"BM31 对称的二叉树","text":"描述给定一棵二叉树，判断其是否是自身的镜像（即：是否对称） 例如： 下面这棵二叉树是对称的 下面这棵二叉树不对称 数据范围： 节点数满足 节点上的值满足 要求： 空间复杂度，时间复杂度 备注： 你可以用递归和迭代两种方法解决这个问题 示例1text12输入：{1,2,2,3,4,4,3}返回值：true 示例2text12输入：{8,6,9,5,7,7,5}返回值：false 解题思路明确问题与思路要点是每个对称节点都为真的情况下，一个二叉树才是对称的，即为真。只要有一对节点为假，即可判断为不对称。判断顺序 判断对称节点是否都为空，若都为空，对称且该路径为尽头返回True。 判断对称节点是否有一个不为空，若有一个不为空则说明不对称，返回False。 递归调用，返回结果为当前两节点值的bool值与后续两对对称节点的bool值的与运算值（and） 12345678910111213141516171819202122232425# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = None## 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可## # @param pRoot TreeNode类 # @return bool布尔型#class Solution: def isSymmetrical(self , pRoot: TreeNode) -&gt; bool: def isMirror(left: TreeNode, right: TreeNode) -&gt; bool: if not left and not right: return True if not left or not right: return False return (left.val == right.val) and isMirror(left.left, right.right) and isMirror(left.right, right.left) if not pRoot: return True return isMirror(pRoot.left, pRoot.right)","link":"https://guodnuli.github.io/2023/09/12/BM31%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"title":"BM32合并二叉树","text":"描述已知两颗二叉树，将它们合并成一颗二叉树。合并规则是：都存在的结点，就将结点值加起来，否则空的位置就由另一个树的结点来代替。例如： 两颗二叉树是: Tree1 Tree2 合并后的树为 数据范围：树上节点数量满足，树上节点的值一定在32位整型范围内。 进阶：空间复杂度 ，时间复杂度 示例1text123输入：{1,3,2,5},{2,1,3,#,4,#,7}返回值：{3,4,5,5,4,#,7}说明：如题面图 示例2text12输入：{1},{}返回值：{1} 解题思路 判断t1或t2是否为None，为None直接返回对应节点指针 都不为None时创建节点，值为t1.val + t2.val 递归调用左节点和右节点，并返回此栈帧创造的节点指针 12345678910111213141516171819202122232425# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = None## 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可# # @param t1 TreeNode类 # @param t2 TreeNode类 # @return TreeNode类#class Solution: def mergeTrees(self , t1: TreeNode, t2: TreeNode) -&gt; TreeNode: if not t1: return t2 if not t2: return t1 merged = TreeNode(t1.val + t2.val) merged.left = self.mergeTrees(t1.left, t2.left) merged.right = self.mergeTrees(t1.right, t2.right) return merged","link":"https://guodnuli.github.io/2023/09/13/BM32%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"title":"注意力与自注意机制模型","text":"注意力是什么 视觉注意力是人类大脑处理视觉信号的处理机制。人类通过快速扫描全局图像，获取需要重点关注的目标区域，也就是注意力焦点，而后再对这一区域投入更多资源，以获取更多所需关注目标的细节信息。 模型输入复杂输入输入为单个向量 输入为向量集合 以向量集合作为输入例句：this is a cat One-hot Encoding在这个句子中，我们可以将每个单词量化为一个向量，建立一个简单的映射，即One-hot Encoding（独热编码）。在这个编码体系中。 优点： 对于人类来说，可读性高。 缺点： 稀疏矩阵，数据利用率低。 每个单词的向量维度太高（长度太长），几乎无法处理。 text123456One-hot Encodingapple = [1 0 0 0 0......]bag = [0 1 0 0 0......]cat = [0 0 1 0 0......]dog = [0 0 0 1 0......]elephant = [0 0 0 0 1......] Word EmbeddingWord Embedding（词嵌入）是自然语言处理和机器学习中用于表示词或短语的技术。词嵌入通过将单词或短语映射到向量空间中的实数向量来捕获单词之间的语义关系，这些实数向量的维度通常远小于词汇表的大小。这种转换使得词汇中的单词在计算机中有了稠密的数值表示，从而方便了后续的计算和处理。 Word Embedding的主要特点： 语义关系：相似或相关的词在向量空间中往往距离接近。 维度缩减：将高维的One-hot Encoding转化为较低的维度，通常为几十到几百维。 可以被训练：虽然有预训练的词嵌入模型可供使用，但可以根据特定任务进一步训练它们。 捕获复杂的关系：例如，利用词嵌入，某些算法可以识别”king” - “man” + “woman”接近于”queen”。 Word Embedding可视化 TensorFlow Document 可视化 模型输出 每个向量对应一个输出 所有向量对应一个输出 模型自己决定输出 序列标注Sequence labeling（序列标注）是自然语言处理中的一种常见任务，其目标是为序列中的每个元素分配一个标签。这种任务特别适合于那些单词或标记的标签依赖于其上下文（即它在序列中的前后位置）的情境。 常见的序列标注任务包括： **词性标注 (Part-of-Speech Tagging)**：为每个单词分配一个词性标签，如名词、动词、形容词等。 例如: 输入: “She loves coding.” 输出: “She/PRP loves/VBZ coding/VBG ./.” **命名实体识别 (Named Entity Recognition, NER)**：识别文本中的命名实体，如人名、地点、组织名等，并为这些实体分配标签。 例如: 输入: “Barack Obama was born in Hawaii.” 输出: “Barack Obama/PERSON was/O born/O in/O Hawaii/LOCATION ./.” **分块 (Chunking)**：识别文本中的词组或“块”，如名词短语或动词短语。 例如: 输入: “She loves coding.” 输出: “[She/PRP] [loves/VBZ coding/VBG] ./.” 语言模型标注：为序列中的每个单词预测其后的单词。 自注意机制 Self-attention基础模型 Self-attention层 相关性计算Dot-product Additive 归一化注意力权重通常在归一化注意力权重这一阶段使用Soft-max函数 其中为指数化函数，指数化是指将一个数的底数提高到某个指数的操作。在数学中，指数函数是一个非常基础的函数。例如，对于数进行指数化操作为 在上述的自注意力机制的公式中，指数化的操作有两个目的： 确保所有的得分都是正的：无论 的值是正还是负，经过指数函数处理后的结果都是正数。 增大得分之间的差异：有助于使得原本就较大的得分在指数化后变得更大，而原本较小的得分变得更小，这样有助于在softmax操作中将更多的注意力集中在原本得分较高的部分。 事实上在归一化注意力权重时除了使用softmax函数，还可以使用其他函数 Sigmoid函数 Tanh函数 Gated Softmax Sparsemax Entmax函数 Power Mean函数 他们在不同的任务中可能会产生比Softmax更好的效果，因此需要具体情况具体分析使用哪一种归一化注意力权重的方式。当然Softmax还是最常见的归一化方式。 计算归一化注意力权重 计算注意力得分 即包含向量对于当前所有向量相关性数据的一个新的向量，然后投入到Full-connected层内进行计算。 继续计算、、 是如何产生的？实际上是三个矩阵的分量形式，这些分量合并起来就如同下面三幅图的左侧展示的那样，而想要计算获得这三个矩阵，我们需要三个对应的权重矩阵，即。将他们与我们输入的a组成的矩阵相乘后，即可得到，这三个矩阵称为Query，Key，Value，中文译为查询，键，值（命名真的挺抽象的，Google论文里的命名）。 然后在我们训练模型的时候，三个权重矩阵会随训练结果进行修正，直到训练结束才会定下具体数值，因此我们可以随机初始化这三个权重矩阵以开始我们的训练。 矩阵乘法 如何通过矩阵与向量之间的共性使我们的向量内积与向量外积拓展至矩阵相乘呢？ 计算过程 至此，我们就得到了self-attention这层的输出，它是由四个向量组成的一个4x4矩阵（因为我们的输入是4个4维度的单词向量），这个矩阵内已经包含了这些单词之间的全局相关性数据。因此模型获得了关联上下文进行文本生成的能力。 全局相关性可视化","link":"https://guodnuli.github.io/2023/10/28/%E6%B3%A8%E6%84%8F%E5%8A%9B%E4%B8%8E%E8%87%AA%E6%B3%A8%E6%84%8F%E6%9C%BA%E5%88%B6%E6%A8%A1%E5%9E%8B/"}],"tags":[{"name":"链表,牛客网","slug":"链表-牛客网","link":"https://guodnuli.github.io/tags/%E9%93%BE%E8%A1%A8-%E7%89%9B%E5%AE%A2%E7%BD%91/"},{"name":"二分法,牛客网","slug":"二分法-牛客网","link":"https://guodnuli.github.io/tags/%E4%BA%8C%E5%88%86%E6%B3%95-%E7%89%9B%E5%AE%A2%E7%BD%91/"},{"name":"二叉树,牛客网","slug":"二叉树-牛客网","link":"https://guodnuli.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91-%E7%89%9B%E5%AE%A2%E7%BD%91/"},{"name":"二叉树","slug":"二叉树","link":"https://guodnuli.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"牛客网","slug":"牛客网","link":"https://guodnuli.github.io/tags/%E7%89%9B%E5%AE%A2%E7%BD%91/"},{"name":"RNN,大语言模型","slug":"RNN-大语言模型","link":"https://guodnuli.github.io/tags/RNN-%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B/"}],"categories":[{"name":"每日一题","slug":"每日一题","link":"https://guodnuli.github.io/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"name":"深度学习","slug":"深度学习","link":"https://guodnuli.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}]}